#!/usr/bin/env python

# How to mount the File-System:
#   ramfs mountpoint
#
# How to umount the File-System?
#   umount mountpoint

import os, sys, stat, errno, time
import fuse

# Specify what Fuse API use: 0.2
fuse.fuse_python_api = (0, 2)

# redirect stdout to a log (unbuffered)
sys.stdout = open('syslogfs.log', 'a', 0)
sys.stderr = open('errlogfs.log', 'a', 0)

class Inode(object):

   DIR  = 'dir'
   FILE = 'file'
   LINK = 'link'

   def __init__(self, type, name, mode, uid, gid):

      self.type = type
      self.name = name    # file name
      self.dev  = 0      # device ID (if special file)
      self.mode = mode    # protection and file-type
      self.uid  = uid     # user ID of owner
      self.gid  = gid     # group ID of owner

      self.now()

      # Extended Attributes
      self.xattr = {}

      # Data 
      if stat.S_ISDIR(mode):
         self.data = set()
      else:
         self.data = ''

   def now(self):
      self.atime = time.time()   # time of last acces
      self.mtime = self.atime   # time of last modification
      self.ctime = self.atime   # time of last status change

   def stat(self):
      stat = fuse.Stat()
      stat.st_mode  = self.mode      # protection bits
      stat.st_ino   = 0            # inode number
      stat.st_dev   = self.dev      # device
      stat.st_nlink = 2            # number of hard links
      stat.st_uid   = self.uid      # user ID of owner
      stat.st_gid   = self.gid      # group ID of owner
      stat.st_size  = len(self.data)  # size of file, in bytes
      stat.st_atime = self.atime     # time of most recent access
      stat.st_mtime = self.mtime     # time of most recent content modification
      stat.st_ctime = self.ctime     # platform dependent; time of most recent metadata change on Unix, or the time of creation on Windows
      return stat

   def child(self, path):
      match = None
      if self.type == Inode.DIR:
         nodes = path.split('/')
         for child in self.data:
            if child.name == nodes[0]:
               if len(nodes) > 1:
                  match = child.child('/'.join(nodes[1:]))
               else:
                  match = child
      return match

   def read(self, offset, length):
      stat.st_atime = time.time()
      print 'NODE READ ', str(self.data[offset:offset+length])
      return self.data[offset:offset+length]

   def write(self, offset, data):
      length = len(data)
      self.data = self.data[:offset] + data + self.data[offset+length:]
      self.now()
      return length

   def truncate(self, length):
      self.data = self.data[0:length]
      self.now()


class PeRamFS(fuse.Fuse):

   def __init__(self, *args, **kwargs):
      fuse.Fuse.__init__(self, *args, **kwargs)

      self.uid = os.getuid()
      self.gid = os.getgid()

   def fsinit(self):
      # print 'fsinit'
      # initialize the root inode
      self.root = Inode(Inode.DIR, 'root', 0755 | stat.S_IFDIR, self.uid, self.gid)

      # background threads need to be initialized here
      # this is where we will spawn our persistence thread

   # --- Metadata 
   def getattr(self, path):
      print 'getattr path:%s' % path
      node = self._node(path)
      if not node:
         return -errno.ENOENT
      else:
         return node.stat()

   def mythread(self):
      print '*** mythread'
      return -errno.ENOSYS

   def chmod(self, path, mode):
      print 'chmod path:%s mode:%s' % (path, mode)
      node = self._node(path)
      if not node:
         return -errno.ENOENT
      node.mode = mode

   def chown(self, path, uid, gid):
      print 'chown path:%s uid:%s gid:%s' % (path, uid, gid)
      node = self._node(path)
      if not node:
         return -errno.ENOENT
      node.uid = uid
      node.gid = gid

   def fsync(self, path, uid, gid):
      print 'fsync', path, uid, gid
      #return -errno.ENOSYS

   def link(self, target, link):
      print '*** link', target, link
      return -errno.ENOSYS

   def open(self, path, flags):
      print 'open', path, flags
      return 0
      #return -errno.ENOSYS

   def release(self, path, flags):
      print 'release', path, flags
      #return -errno.ENOSYS

   def statfs(self):
      print '*** statfs'
      return -errno.ENOSYS

   def flush(self, path):
      print 'flush', path
      #return -errno.ENOSYS

   def utime(self, path, times):
      print 'utime path:%s times:%s' % (path, times)
      node = self._node(path)
      if not node:
         return -errno.ENOENT
      node.ctime = node.mtime = times[0]

   def unlink(self, path):
      print 'unlink path:%s' % path

      parent = self._parent(path)
      child  = self._node(path)

      if not (parent or child):
         return -errno.ENOENT

      parent.data.remove(child)

   def rename(self, oldpath, newpath):
      print 'rename oldpath:%s newpath:%s' % (oldpath, newpath)

      filename   = os.path.basename(newpath)
      old_parent = self._parent(oldpath)
      new_parent = self._parent(newpath)
      node      = self._node(oldpath) 

      if not (old_parent or new_parent or node):
         return -errno.ENOENT

      if not new_parent.type == Inode.DIR:
         return -errno.ENOTDIR

      node.name = filename
      old_parent.data.remove(node)
      new_parent.data.add(node)

   # --- Links 
   def symlink(self, path, newpath):
      print 'symlink path:%s newpath:%s' % (path, newpath)

      source_node = self._node(path)
      filename   = os.path.basename(newpath)
      parent     = self._parent(newpath)

      if not (parent or source_node):
         return -errno.ENOENT

      if not parent.type == Inode.DIR:
         return -errno.ENOTDIR

      node = Inode(Inode.LINK, filename, 0644 | stat.S_IFLNK, self.uid, self.gid)
      node.data = path

      parent.data.add(node)

   def readlink(self, path):
      print 'readlink path:%s' % path

      node = self._node(path)
      if not node:
         return -errno.ENOENT

      return node.data

   # --- Extra Attributes 
   def setxattr(self, path, name, value, flags):
      print 'setxattr path:%s name:%s value:%s flags:%s' % (path, name, value, flags)

      node = self._node(path)
      if not node:
         return -errno.ENOENT

      node.xattr[name] = value


   def getxattr(self, path, name, size):
      print 'getxattr path:%s name:%s size:%s' % (path, name, size)

      node = self._node(path)
      if not node:
         return -errno.ENOENT

      value = node.xattr.get(name, '')
      if size == 0:   # We are asked for size of the value
         return len(value)

      return value


   def listxattr(self, path, size):
      print 'listxattr path:%s size:%s' % (path, size)

      node = self._node(path)
      if not node:
         return -errno.ENOENT

      attrs = node.xattr.keys()
      if size == 0:
         return len(attrs) + len(''.join(attrs))
      return attrs


   def removexattr(self, path, name):
      print 'removexattr path:%s name:%s' % (path, name)

      node = self._node(path)
      if not node:
         return -errno.ENOENT

      if name in node.xattr:
         del node.xattr[name]


   # --- Files 

   # this appears to be the fallback if create fails
   def mknod(self, path, mode, dev):
      print 'mknod path:%s mode:%s dev:%s' % (path, mode, dev)

      filename   = os.path.basename(path)
      parent     = self._node(path)

      if not parent:
         return -errno.ENOENT

      if not parent.type == Inode.DIR:
         return -errno.ENOTDIR

      node = Inode(Inode.FILE, filename, mode, self.uid, self.gid)
      node.dev = dev
      parent.data.add(node)      

   def create(self, path, flags, mode):
      print 'create path:%s flags:%s mode:%s' % (path, flags, mode)

      filename = os.path.basename(path)
      parent   = self._parent(path)

      if not parent:
         return -errno.ENOENT

      if not parent.type == Inode.DIR:
         return -errno.ENOTDIR

      print "parent %s" % parent
      node = Inode(Inode.FILE, filename, mode | stat.S_IFREG, self.uid, self.gid)
      parent.data.add(node)
      print 'node', str(node)
     
   def truncate(self, path, len):
      print 'truncate path:%s len:%s' % (path, len)

      node = self._node(path)

      if not node:
         return -errno.ENOENT

      node.truncate(len)


   def read(self, path, size, offset):
      print 'read path:%s size:%s offset:%s' % (path, size, offset)

      node = self._node(path)

      if not node:
         return -errno.ENOENT

      return node.read(offset, size)

   def write(self, path, buf, offset):
      print 'write path:%s buf:%s offset:%s' % (path, buf, offset)

      node = self._node(path)

      if not node:
         return -errno.ENOENT

      return node.write(offset, buf)

   # --- Directories 
   def mkdir(self, path, mode):
      # print 'mkdir path:%s mode:%s' % (path, mode)

      filename   = os.path.basename(path)
      parent     = self._parent(path)

      if not parent:
         return -errno.ENOENT

      if not parent.type == Inode.DIR:
         return -errno.ENOTDIR

      node = Inode(Inode.DIR, filename, mode | stat.S_IFDIR, self.uid, self.gid)
      parent.data.add(node)

   def rmdir(self, path):
      # print 'rmdir path:%s' % path

      parent     = self._parent(path)
      node      = self._node(path)

      if not (parent or node):
         return -errno.ENOENT

      if not node.type == Inode.DIR:
         return -errno.ENOTDIR
      
      parent.data.remove(node)


   def readdir(self, path, offset):
      # print 'readdir path:%s offset:%s' % (path, offset)

      node = self._node(path)

      if node.type == Inode.DIR:
         for meta in ['.', '..']:
            yield fuse.Direntry(meta)
         for child in node.data:
            yield fuse.Direntry(child.name) 
      else:
         yield fuse.Direntry(node.name)

   # --- Tree Helpers
   def _node(self, path):
      if path == '/':
         return self.root
      else:
         return self.root.child(path[1:])

   def _parent(self, path):
      parent_path = os.path.dirname(path)
      return self._node(parent_path)

def usage():
   usage = '''
ramfs - File-System in RAM

   '''
   return usage


def main():
   version = "%prog " + fuse.__version__
   peramfs  = PeRamFS(version=version, usage=usage(), dash_s_do='setsingle')
   args   = peramfs.parse(errex=1)
   peramfs.flags = 0
   peramfs.multithreaded = 0
   peramfs.main()

if __name__ == '__main__':
   main()
   
     
   
